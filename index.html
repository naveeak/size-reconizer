<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TailoredAI - T-Shirt Size Predictor</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>

    <!-- SheetJS for Excel Export -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>

    <!-- MediaPipe BlazePose -->
    <script
        src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.min.js"></script>

    <!-- OpenCV.js -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();"
        type="text/javascript"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* Custom Animations */
        @keyframes scan {
            0% {
                top: 0%;
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                top: 100%;
                opacity: 0;
            }
        }

        .scan-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 4px;
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
            animation: scan 2s linear infinite;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
        }

        /* Scrollbar for dashboard */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #f3f4f6;
        }

        ::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        /* Premium Font */
        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }

        /* Instruction Banner Modal */
        .instruction-modal {
            position: fixed;
            inset: 0;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(8px);
        }

        .instruction-modal.hidden {
            display: none;
        }

        .instruction-card {
            background: white;
            border-radius: 1.5rem;
            padding: 2rem;
            max-width: 500px;
            margin: 1rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .do-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.5rem 0;
        }

        .do-icon {
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            font-size: 0.75rem;
        }

        .do-icon.green {
            background: #dcfce7;
            color: #16a34a;
        }

        .do-icon.red {
            background: #fee2e2;
            color: #dc2626;
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-900 h-screen overflow-hidden flex flex-col font-sans">

    <!-- Header -->
    <header class="h-16 flex items-center justify-between px-8 bg-white border-b border-gray-200 z-10 shadow-sm">
        <div class="flex items-center gap-3 cursor-pointer" onclick="app.toggleDashboard()">
            <span class="text-2xl">üìè</span>
            <h1 class="text-xl font-bold text-gray-900 tracking-tight">
                TAILORED<span class="font-light text-gray-500">AI</span>
            </h1>
        </div>
        <div class="flex items-center gap-4">
            <button onclick="app.toggleDashboard()"
                class="text-sm font-medium text-gray-600 hover:text-gray-900 flex items-center gap-2 transition-colors">
                <span class="bg-gray-100 p-2 rounded-full">üìä</span> <span class="hidden md:inline">Dashboard</span>
            </button>
            <div id="status-indicator"
                class="flex items-center gap-2 px-4 py-1.5 rounded-full bg-blue-50 text-blue-700 text-xs font-semibold uppercase tracking-wide border border-blue-100">
                <span class="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></span>
                <span id="status-text">Initializing...</span>
            </div>
        </div>
    </header>

    <!-- Instruction Banner Modal -->
    <div id="instruction-modal" class="instruction-modal">
        <div class="instruction-card">
            <div class="text-center mb-6">
                <span class="text-4xl">üìè</span>
                <h2 class="text-2xl font-bold text-gray-900 mt-3">Before You Start</h2>
                <p class="text-gray-500 mt-1">Follow these instructions for accurate measurements</p>
            </div>

            <div class="bg-blue-50 border border-blue-200 rounded-xl p-4 mb-4">
                <p class="text-blue-800 font-bold text-center text-lg">üìç Stand 2 meters (~6.5 feet) from camera</p>
            </div>

            <div class="grid grid-cols-2 gap-4">
                <!-- DO's -->
                <div>
                    <h3 class="font-bold text-green-700 mb-2 flex items-center gap-2">
                        <span class="text-lg">‚úÖ</span> DO's
                    </h3>
                    <div class="space-y-2 text-sm text-gray-600">
                        <div class="do-item">
                            <span class="do-icon green">‚úì</span>
                            <span>Show upper body (head to hips)</span>
                        </div>
                        <div class="do-item">
                            <span class="do-icon green">‚úì</span>
                            <span>Keep arms relaxed at sides</span>
                        </div>
                        <div class="do-item">
                            <span class="do-icon green">‚úì</span>
                            <span>Face the camera directly</span>
                        </div>
                        <div class="do-item">
                            <span class="do-icon green">‚úì</span>
                            <span>Wear fitted clothing</span>
                        </div>
                    </div>
                </div>

                <!-- DON'Ts -->
                <div>
                    <h3 class="font-bold text-red-700 mb-2 flex items-center gap-2">
                        <span class="text-lg">‚ùå</span> DON'Ts
                    </h3>
                    <div class="space-y-2 text-sm text-gray-600">
                        <div class="do-item">
                            <span class="do-icon red">‚úó</span>
                            <span>Stand too close or far</span>
                        </div>
                        <div class="do-item">
                            <span class="do-icon red">‚úó</span>
                            <span>Wear loose/bulky clothes</span>
                        </div>
                        <div class="do-item">
                            <span class="do-icon red">‚úó</span>
                            <span>Move while measuring</span>
                        </div>
                        <div class="do-item">
                            <span class="do-icon red">‚úó</span>
                            <span>Tilt your body</span>
                        </div>
                    </div>
                </div>
            </div>

            <button onclick="app.dismissInstructions()"
                class="w-full mt-6 py-3 bg-gray-900 hover:bg-gray-800 text-white rounded-xl font-bold tracking-wide transition-all shadow-lg hover:shadow-xl">
                Got it! Let's Start
            </button>
        </div>
    </div>

    <!-- Main Content -->
    <main class="flex-1 relative flex flex-col md:flex-row overflow-hidden">

        <!-- Dashboard Overlay (Initially Hidden) -->
        <div id="dashboard-view"
            class="hidden absolute inset-0 z-60 bg-white/95 backdrop-blur-sm flex flex-col p-8 overflow-hidden transition-all duration-300">
            <div class="flex justify-between items-center mb-8 max-w-6xl mx-auto w-full">
                <div>
                    <h2 class="text-3xl font-bold text-gray-900">Team Measurements</h2>
                    <p class="text-gray-500 mt-1">Export this list and share with manufacturers.</p>
                </div>
                <div class="flex gap-3">
                    <button onclick="app.clearAllData()"
                        class="px-5 py-2.5 bg-red-100 hover:bg-red-200 text-red-700 rounded-lg font-medium transition-all">
                        üóëÔ∏è Clear All
                    </button>
                    <button onclick="app.exportToExcel()"
                        class="px-5 py-2.5 bg-green-600 hover:bg-green-700 text-white rounded-lg font-medium shadow-sm flex items-center gap-2 transition-all">
                        üì• Export Excel
                    </button>
                    <button onclick="app.toggleDashboard()"
                        class="px-5 py-2.5 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg font-medium transition-all">
                        Close
                    </button>
                </div>
            </div>

            <div
                class="flex-1 overflow-auto bg-white rounded-2xl border border-gray-200 shadow-xl max-w-6xl mx-auto w-full">
                <table class="w-full text-left border-collapse">
                    <thead class="bg-gray-50 text-gray-600 sticky top-0 z-10">
                        <tr>
                            <th class="p-4 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">
                                Employee</th>
                            <th class="p-4 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">Size
                            </th>
                            <th class="p-4 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">
                                Chest</th>
                            <th class="p-4 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">
                                Shoulder</th>
                            <th class="p-4 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">
                                Status</th>
                            <th class="p-4 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">Date
                            </th>
                            <th class="p-4 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">
                                Photo</th>
                        </tr>
                    </thead>
                    <tbody id="history-table-body" class="divide-y divide-gray-100 text-gray-700">
                        <!-- Rows will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Video Feed Area -->
        <div class="relative flex-1 bg-gray-100 flex items-center justify-center overflow-hidden">
            <div class="relative w-full h-full max-w-4xl max-h-[80vh] rounded-2xl overflow-hidden shadow-2xl bg-black">
                <!-- Video Element (Hidden, used for processing) -->
                <video id="webcam" class="absolute inset-0 w-full h-full object-cover opacity-0" playsinline></video>

                <!-- Canvas Overlay (Visible) -->
                <canvas id="output-canvas" class="absolute inset-0 w-full h-full object-contain"></canvas>

                <!-- UI Overlays -->
                <div id="guide-overlay" class="absolute inset-0 pointer-events-none flex items-center justify-center">
                    <!-- Body Silhouette Guide -->
                    <div id="pose-guide" class="hidden absolute inset-0 flex items-center justify-center">
                        <svg id="body-outline" class="w-full h-full" viewBox="0 0 400 600"
                            preserveAspectRatio="xMidYMid meet">
                            <!-- Head Circle -->
                            <circle cx="200" cy="80" r="45" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="3"
                                stroke-dasharray="8,4" />

                            <!-- Neck -->
                            <line x1="200" y1="125" x2="200" y2="150" stroke="rgba(255,255,255,0.4)" stroke-width="2"
                                stroke-dasharray="4,4" />

                            <!-- Shoulders Line with markers -->
                            <line id="shoulder-guide" x1="100" y1="170" x2="300" y2="170" stroke="rgba(0,255,255,0.8)"
                                stroke-width="4" stroke-dasharray="10,5" />
                            <circle cx="100" cy="170" r="12" fill="none" stroke="rgba(0,255,255,0.8)"
                                stroke-width="3" />
                            <circle cx="300" cy="170" r="12" fill="none" stroke="rgba(0,255,255,0.8)"
                                stroke-width="3" />
                            <text x="50" y="175" fill="rgba(255,255,255,0.7)" font-size="12"
                                font-family="sans-serif">L</text>
                            <text x="320" y="175" fill="rgba(255,255,255,0.7)" font-size="12"
                                font-family="sans-serif">R</text>

                            <!-- Torso outline -->
                            <path d="M100,170 Q80,250 90,350 L110,450 L290,450 L310,350 Q320,250 300,170" fill="none"
                                stroke="rgba(255,255,255,0.4)" stroke-width="2" stroke-dasharray="8,4" />

                            <!-- Arms (relaxed position) -->
                            <path d="M100,170 Q60,200 50,280" fill="none" stroke="rgba(255,255,255,0.3)"
                                stroke-width="2" stroke-dasharray="6,4" />
                            <path d="M300,170 Q340,200 350,280" fill="none" stroke="rgba(255,255,255,0.3)"
                                stroke-width="2" stroke-dasharray="6,4" />

                            <!-- Center line -->
                            <line x1="200" y1="150" x2="200" y2="450" stroke="rgba(255,255,255,0.2)" stroke-width="1"
                                stroke-dasharray="4,4" />

                            <!-- Hip line -->
                            <line x1="110" y1="450" x2="290" y2="450" stroke="rgba(255,255,255,0.4)" stroke-width="2"
                                stroke-dasharray="6,4" />
                        </svg>

                        <!-- Distance indicator -->
                        <div id="distance-indicator"
                            class="absolute bottom-20 left-1/2 transform -translate-x-1/2 px-4 py-2 rounded-full text-sm font-bold transition-all duration-300 bg-yellow-500/80 text-black">
                            üìè Stand at 2 meters
                        </div>
                    </div>
                </div>

                <!-- Manual Capture Button Removed -->

                <!-- Pose Guidance Overlay -->
                <div id="pose-guidance" class="hidden absolute top-4 left-4 right-4 z-20">
                    <!-- Guidance Text -->
                    <div class="bg-black/70 backdrop-blur-sm rounded-xl p-4 text-center">
                        <p id="guidance-text" class="text-white font-bold text-lg">Stand in frame</p>
                        <p id="guidance-hint" class="text-white/70 text-sm mt-1">Position yourself so shoulders are
                            visible</p>
                    </div>
                    <!-- Progress Bar -->
                    <div class="mt-3 bg-white/20 rounded-full h-2 overflow-hidden">
                        <div id="capture-progress" class="h-full bg-green-500 transition-all duration-200"
                            style="width: 0%"></div>
                    </div>
                    <p id="progress-text" class="text-white/80 text-xs text-center mt-1">0 / 30 samples</p>
                </div>

                <!-- Loading Spinner -->
                <div id="loader" class="absolute inset-0 flex flex-col items-center justify-center bg-white z-50">
                    <div class="w-16 h-16 border-4 border-gray-200 border-t-gray-900 rounded-full animate-spin mb-6">
                    </div>
                    <p class="text-gray-500 font-medium tracking-wide animate-pulse">INITIALIZING AI...</p>
                </div>
            </div>
        </div>

        <!-- Sidebar / Results Panel -->
        <div
            class="md:w-96 bg-white border-l border-gray-200 flex flex-col z-20 shadow-xl transition-transform duration-300 transform translate-y-full md:translate-y-0 absolute md:relative bottom-0 w-full h-2/3 md:h-full">

            <!-- Instructions Panel -->
            <div id="instructions-panel" class="p-8 flex-1 overflow-y-auto">
                <!-- Employee Name Input -->
                <div class="mb-6">
                    <h2 class="text-xs font-bold text-gray-400 uppercase tracking-widest mb-3">Employee Details</h2>
                    <input type="text" id="input-employee-name" placeholder="Enter Employee Name or ID"
                        class="w-full px-4 py-3 bg-white border border-gray-200 rounded-lg text-gray-900 font-medium focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent" />
                </div>

                <h2 class="text-xs font-bold text-gray-400 uppercase tracking-widest mb-4">Quick Guide</h2>

                <div class="space-y-4">
                    <div class="flex gap-4 items-start">
                        <div
                            class="w-8 h-8 rounded-full bg-green-100 text-green-600 flex items-center justify-center font-bold shrink-0 text-sm">
                            1</div>
                        <p class="text-sm text-gray-500"><b>Position:</b> Stand <b>2 meters</b> (~6.5 feet) from the
                            camera.</p>
                    </div>
                    <div class="flex gap-4 items-start">
                        <div
                            class="w-8 h-8 rounded-full bg-green-100 text-green-600 flex items-center justify-center font-bold shrink-0 text-sm">
                            2</div>
                        <p class="text-sm text-gray-500"><b>Pose:</b> Show upper body (head to hips), arms relaxed at
                            sides.</p>
                    </div>
                    <div class="flex gap-4 items-start">
                        <div
                            class="w-8 h-8 rounded-full bg-green-100 text-green-600 flex items-center justify-center font-bold shrink-0 text-sm">
                            3</div>
                        <p class="text-sm text-gray-500"><b>Wait:</b> Hold still while 30 samples are captured
                            automatically.</p>
                    </div>
                </div>

                <div class="mt-6 p-4 bg-blue-50 rounded-xl border border-blue-100">
                    <p class="text-sm text-blue-800 font-medium">üìç Accurate distance = accurate measurements!</p>
                </div>

                <div class="mt-3 p-4 bg-amber-50 rounded-xl border border-amber-100">
                    <p class="text-sm text-amber-800 font-medium">üí° Enter employee name BEFORE measuring.</p>
                </div>
            </div>

            <!-- Results Panel (Hidden initially) -->
            <div id="results-panel" class="hidden absolute inset-0 bg-white p-8 flex flex-col overflow-y-auto">
                <div class="text-center mb-4">
                    <h2 class="text-2xl font-bold text-gray-900">Analysis Complete</h2>
                    <p class="text-gray-500 text-sm">Review your measurements. Edit if needed.</p>
                </div>

                <div class="flex-1 flex flex-col items-center justify-center">
                    <!-- 3D Model Container -->
                    <div id="three-container"
                        class="w-full h-40 bg-gray-50 rounded-xl mb-4 overflow-hidden border border-gray-100 relative">
                        <!-- Canvas will be injected here -->
                    </div>

                    <div class="relative mb-4">
                        <div class="absolute inset-0 bg-gray-900 rounded-full opacity-5 blur-xl"></div>
                        <div
                            class="relative w-20 h-20 rounded-full bg-gray-900 flex items-center justify-center shadow-2xl">
                            <span id="result-size" class="text-3xl font-bold text-white">L</span>
                        </div>
                    </div>

                    <!-- Editable Measurements -->
                    <div class="w-full space-y-3 bg-gray-50 p-5 rounded-2xl border border-gray-100">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-500 text-sm font-medium">Chest (cm)</span>
                            <div class="flex items-center gap-2">
                                <input type="number" id="input-chest"
                                    class="w-20 text-right font-mono font-bold text-gray-900 text-lg bg-white border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500" />
                                <button onclick="app.recalculateSize()"
                                    class="text-blue-600 hover:text-blue-800 text-xs font-medium">Update</button>
                            </div>
                        </div>
                        <div class="w-full h-px bg-gray-200"></div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-500 text-sm font-medium">Shoulder (cm)</span>
                            <div class="flex items-center gap-2">
                                <input type="number" id="input-shoulder"
                                    class="w-20 text-right font-mono font-bold text-gray-900 text-lg bg-white border border-gray-200 rounded-lg px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500" />
                            </div>
                        </div>
                    </div>

                    <!-- Edit Notice -->
                    <p id="edit-notice" class="hidden mt-3 text-xs text-amber-600 font-medium">‚ö†Ô∏è Measurements were
                        manually edited</p>
                </div>

                <div class="mt-6 space-y-3">
                    <button onclick="app.saveCurrentResult()"
                        class="w-full py-3 bg-gray-900 hover:bg-gray-800 text-white rounded-xl font-bold tracking-wide transition-all shadow-lg hover:shadow-xl transform hover:-translate-y-0.5">
                        SAVE RESULT
                    </button>
                    <button onclick="app.reset()"
                        class="w-full py-3 bg-white border border-gray-200 hover:bg-gray-50 text-gray-900 rounded-xl font-bold tracking-wide transition-colors">
                        MEASURE AGAIN
                    </button>
                </div>
            </div>

        </div>
    </main>

    <script>
        // --- APP STATE & CONFIG ---
        const CONFIG = {
            // Fixed distance calibration (2 meters from camera)
            cameraDistanceMeters: 2.0,
            cameraFovDegrees: 60, // Standard webcam FOV
            confidenceThreshold: 0.6,
            smoothingWindow: 10
        };

        const STATE = {
            INIT: 'initializing',
            WAITING_PERMISSIONS: 'waiting_permissions',
            DETECTING_POSE: 'detecting_pose',
            CALCULATING: 'calculating',
            SHOW_RESULTS: 'results',
            ERROR: 'error'
        };

        // --- DATABASE HELPER ---
        const DB_NAME = 'SizeAIDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'measurements';

        class Database {
            constructor() {
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);

                    request.onerror = (event) => {
                        console.error("DB Error", event);
                        reject("DB Error");
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            db.createObjectStore(STORE_NAME, { keyPath: "id", autoIncrement: true });
                        }
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log("DB Initialized");
                        resolve();
                    };
                });
            }

            async save(data) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([STORE_NAME], "readwrite");
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.add(data);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getAll() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([STORE_NAME], "readonly");
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async clearAll() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([STORE_NAME], "readwrite");
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.clear();

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }
        }

        // --- GLOBAL VARIABLES ---
        let appState = STATE.INIT;
        let video, canvas, ctx;
        let detector;
        let scalePxPerCm = 0;
        let measurements = [];
        let opencvLoaded = false;
        let db = new Database();
        let currentResult = null; // Store temp result for saving
        let threeScene, threeCamera, threeRenderer, torsoMesh;
        let originalChestCm = 0; // Track original AI-detected values
        let originalShoulderCm = 0;
        let wasEdited = false;

        // --- MAIN APP CLASS ---
        class App {
            constructor() {
                this.init();
            }

            async init() {
                this.updateStatus(STATE.INIT);

                video = document.getElementById('webcam');
                canvas = document.getElementById('output-canvas');
                ctx = canvas.getContext('2d');

                try {
                    // 0. Init DB
                    await db.init();

                    // 1. Setup Camera
                    await this.setupCamera();

                    // 2. Load Models
                    await this.loadModels();

                    // 3. Wait for OpenCV
                    await this.waitForOpenCV();

                    // 4. Start Loop - go directly to pose detection
                    this.updateStatus(STATE.DETECTING_POSE);
                    document.getElementById('loader').classList.add('hidden');
                    this.loop();

                } catch (error) {
                    console.error("Initialization failed:", error);
                    this.showError(error.message);
                }
            }

            async setupCamera() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    }
                });
                video.srcObject = stream;

                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        // CRITICAL FIX: Set explicit attributes for OpenCV
                        video.width = video.videoWidth;
                        video.height = video.videoHeight;
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        resolve();
                    };
                });
            }

            async loadModels() {
                await tf.ready();
                // Use BlazePose HEAVY model for maximum accuracy
                // Heavy model is larger but provides best pose detection
                detector = await poseDetection.createDetector(
                    poseDetection.SupportedModels.BlazePose,
                    {
                        runtime: 'tfjs',
                        modelType: 'heavy',  // UPGRADED: lite < full < heavy
                        enableSmoothing: true,
                        solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/pose'
                    }
                );
                console.log("BlazePose Heavy model loaded");
            }

            async waitForOpenCV() {
                return new Promise((resolve) => {
                    const check = setInterval(() => {
                        if (typeof cv !== 'undefined' && cv.Mat) {
                            clearInterval(check);
                            opencvLoaded = true;
                            console.log("OpenCV loaded");
                            resolve();
                        }
                    }, 100);
                });
            }

            init3D() {
                const container = document.getElementById('three-container');
                // Wait for container to exist/be visible or just init
                if (!container) return;

                const width = container.clientWidth || 300;
                const height = container.clientHeight || 200;

                threeScene = new THREE.Scene();
                threeScene.background = new THREE.Color(0xf9fafb); // Gray-50

                threeCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                threeCamera.position.z = 5;
                threeCamera.position.y = 0.5;

                threeRenderer = new THREE.WebGLRenderer({ antialias: true });
                threeRenderer.setSize(width, height);
                container.appendChild(threeRenderer.domElement);

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                threeScene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(2, 5, 5);
                threeScene.add(dirLight);

                // Placeholder Torso Geometry
                const geometry = new THREE.CylinderGeometry(0.8, 0.6, 2, 32);
                const material = new THREE.MeshPhongMaterial({ color: 0x111827 }); // Gray-900
                torsoMesh = new THREE.Mesh(geometry, material);
                threeScene.add(torsoMesh);

                // Animation Loop for 3D
                const animate3D = () => {
                    requestAnimationFrame(animate3D);
                    if (torsoMesh) {
                        torsoMesh.rotation.y += 0.01;
                    }
                    threeRenderer.render(threeScene, threeCamera);
                };
                animate3D();
            }

            updateStatus(state, message) {
                appState = state;
                const statusText = document.getElementById('status-text');
                const indicator = document.getElementById('status-indicator');
                const poseGuide = document.getElementById('pose-guide');
                const captureBtn = document.getElementById('capture-container');
                const poseGuidance = document.getElementById('pose-guidance');

                // Reset guides
                poseGuide.classList.add('hidden');
                if (captureBtn) captureBtn.classList.add('hidden');
                if (poseGuidance) poseGuidance.classList.add('hidden');

                switch (state) {
                    case STATE.INIT:
                        statusText.innerText = "Initializing System...";
                        indicator.className = "flex items-center gap-2 px-4 py-1.5 rounded-full bg-blue-50 text-blue-700 text-xs font-semibold uppercase tracking-wide border border-blue-100";
                        break;
                    case STATE.DETECTING_POSE:
                        statusText.innerText = "Stand 2m Away & Pose";
                        indicator.className = "flex items-center gap-2 px-4 py-1.5 rounded-full bg-purple-50 text-purple-700 text-xs font-semibold uppercase tracking-wide border border-purple-100";
                        poseGuide.classList.remove('hidden');
                        if (captureBtn) captureBtn.classList.remove('hidden');
                        if (poseGuidance) poseGuidance.classList.remove('hidden');
                        break;
                    case STATE.SHOW_RESULTS:
                        statusText.innerText = "Analysis Complete";
                        indicator.className = "flex items-center gap-2 px-4 py-1.5 rounded-full bg-green-50 text-green-700 text-xs font-semibold uppercase tracking-wide border border-green-100";
                        break;
                }

                if (message) statusText.innerText = message;
            }

            showError(msg) {
                alert("Error: " + msg);
            }

            reset() {
                measurements = [];
                scalePxPerCm = 0;
                document.getElementById('results-panel').classList.add('hidden');
                document.getElementById('instructions-panel').classList.remove('hidden');

                // Reset progress bar
                const progressBar = document.getElementById('capture-progress');
                const progressText = document.getElementById('progress-text');
                if (progressBar) progressBar.style.width = '0%';
                if (progressText) progressText.innerText = '0 / 30 samples';

                this.updateStatus(STATE.DETECTING_POSE);
            }

            // Dismiss instruction modal
            dismissInstructions() {
                document.getElementById('instruction-modal').classList.add('hidden');
            }

            // Update body outline color based on positioning
            updateBodyOutlineColor(strokeColor, badgeClass, badgeText) {
                const bodyOutline = document.getElementById('body-outline');
                const distanceIndicator = document.getElementById('distance-indicator');

                if (bodyOutline) {
                    // Update all stroke colors in the SVG
                    const elements = bodyOutline.querySelectorAll('circle, line, path');
                    elements.forEach(el => {
                        if (el.id === 'shoulder-guide' || el.getAttribute('stroke')?.includes('0,255,255')) {
                            // Keep shoulder guide with special color
                            el.setAttribute('stroke', strokeColor);
                        }
                    });
                    // Update head circle
                    const headCircle = bodyOutline.querySelector('circle');
                    if (headCircle) headCircle.setAttribute('stroke', strokeColor);
                }

                if (distanceIndicator) {
                    distanceIndicator.className = `absolute bottom-20 left-1/2 transform -translate-x-1/2 px-4 py-2 rounded-full text-sm font-bold transition-all duration-300 ${badgeClass}`;
                    distanceIndicator.innerText = badgeText;
                }
            }

            // Calculate scale based on fixed distance (2 meters)
            calculateFixedScale() {
                // Formula: At distance D with FOV Œ∏, frame width = 2 * D * tan(Œ∏/2)
                // For 60¬∞ FOV at 2m: Frame width ‚âà 2 * 2 * tan(30¬∞) ‚âà 2.31 meters (231 cm)
                const fovRadians = (CONFIG.cameraFovDegrees * Math.PI) / 180;
                const frameWidthCm = 2 * CONFIG.cameraDistanceMeters * 100 * Math.tan(fovRadians / 2);
                scalePxPerCm = canvas.width / frameWidthCm;
                console.log(`Fixed scale calculated: ${scalePxPerCm.toFixed(2)} px/cm at ${CONFIG.cameraDistanceMeters}m`);
            }

            // setCalibrationMethod removed - using fixed distance calibration

            async loop() {
                if (appState === STATE.ERROR) return;

                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                // Calculate fixed scale on first loop if not set
                if (scalePxPerCm === 0) {
                    this.calculateFixedScale();
                }

                // Process pose detection
                if (appState === STATE.DETECTING_POSE) {
                    await this.processPoseDetection();
                }

                requestAnimationFrame(() => this.loop());
            }

            async processPoseDetection() {
                const poses = await detector.estimatePoses(video);

                // Get guidance elements
                const guidanceText = document.getElementById('guidance-text');
                const guidanceHint = document.getElementById('guidance-hint');
                const progressBar = document.getElementById('capture-progress');
                const progressText = document.getElementById('progress-text');

                if (poses.length > 0) {
                    const pose = poses[0];
                    this.drawSkeleton(pose.keypoints);

                    // Check shoulder keypoints
                    const leftShoulder = pose.keypoints[11];
                    const rightShoulder = pose.keypoints[12];
                    const nose = pose.keypoints[0];

                    // Provide positioning guidance and update body outline
                    const bodyOutline = document.getElementById('body-outline');
                    const distanceIndicator = document.getElementById('distance-indicator');

                    if (leftShoulder.score < 0.5 || rightShoulder.score < 0.5) {
                        if (guidanceText) guidanceText.innerText = "üë§ Shoulders Not Visible";
                        if (guidanceHint) guidanceHint.innerText = "Step back until shoulders are in frame";
                        // Red outline - not visible
                        this.updateBodyOutlineColor('rgba(255,100,100,0.6)', 'bg-red-500/80 text-white', '‚ö†Ô∏è Shoulders not visible');
                    } else {
                        // Check if person is too close or too far based on shoulder ratio
                        const shoulderWidthPx = Math.sqrt(
                            Math.pow(leftShoulder.x - rightShoulder.x, 2) +
                            Math.pow(leftShoulder.y - rightShoulder.y, 2)
                        );
                        const frameWidth = canvas.width;
                        const shoulderRatio = shoulderWidthPx / frameWidth;

                        if (shoulderRatio > 0.5) {
                            if (guidanceText) guidanceText.innerText = "‚¨ÖÔ∏è Step Back";
                            if (guidanceHint) guidanceHint.innerText = "You're too close - move to 2m distance";
                            // Red outline - too close
                            this.updateBodyOutlineColor('rgba(255,100,100,0.7)', 'bg-red-500/80 text-white', '‚¨ÖÔ∏è TOO CLOSE - Step Back');
                        } else if (shoulderRatio < 0.12) {
                            if (guidanceText) guidanceText.innerText = "‚û°Ô∏è Step Closer";
                            if (guidanceHint) guidanceHint.innerText = "You're too far - move to 2m distance";
                            // Orange outline - too far
                            this.updateBodyOutlineColor('rgba(255,180,50,0.7)', 'bg-orange-500/80 text-white', '‚û°Ô∏è TOO FAR - Step Closer');
                        } else {
                            // Good position - measuring
                            if (guidanceText) guidanceText.innerText = "‚úÖ Perfect! Hold Still...";
                            if (guidanceHint) guidanceHint.innerText = "Capturing measurement samples";
                            // Green outline - perfect position
                            this.updateBodyOutlineColor('rgba(100,255,100,0.7)', 'bg-green-500/80 text-white', '‚úÖ PERFECT - Hold Still');
                        }
                    }

                    // Measure if conditions are met
                    // CHECK ROTATION: Ensure shoulders are roughly parallel to camera (z-depth difference low)
                    const zDiff = Math.abs(leftShoulder.z - rightShoulder.z);
                    const isRotated = zDiff > 0.1; // Threshold for rotation

                    if (!isRotated && leftShoulder.score > CONFIG.confidenceThreshold && rightShoulder.score > CONFIG.confidenceThreshold && scalePxPerCm > 0) {
                        const dx = leftShoulder.x - rightShoulder.x;
                        const dy = leftShoulder.y - rightShoulder.y;
                        const distPx = Math.sqrt(dx * dx + dy * dy);
                        const shoulderCm = distPx / scalePxPerCm;

                        // Capture Hips for better accuracy (Keypoints 23=Left Hip, 24=Right Hip)
                        const leftHip = pose.keypoints[23];
                        const rightHip = pose.keypoints[24];
                        let hipCm = 0;

                        if (leftHip.score > CONFIG.confidenceThreshold && rightHip.score > CONFIG.confidenceThreshold) {
                            const hipDx = leftHip.x - rightHip.x;
                            const hipDy = leftHip.y - rightHip.y;
                            const hipDistPx = Math.sqrt(hipDx * hipDx + hipDy * hipDy);
                            hipCm = hipDistPx / scalePxPerCm;
                        }

                        // Capture Torso Length (Mid-Shoulder to Mid-Hip)
                        let torsoCm = 0;
                        if (hipCm > 0) {
                            const midShoulderX = (leftShoulder.x + rightShoulder.x) / 2;
                            const midShoulderY = (leftShoulder.y + rightShoulder.y) / 2;
                            const midHipX = (leftHip.x + rightHip.x) / 2;
                            const midHipY = (leftHip.y + rightHip.y) / 2;
                            const torsoPx = Math.sqrt(Math.pow(midShoulderX - midHipX, 2) + Math.pow(midShoulderY - midHipY, 2));
                            torsoCm = torsoPx / scalePxPerCm;
                        }

                        // Only add reasonable measurements (30-60cm shoulder width)
                        if (shoulderCm > 30 && shoulderCm < 60) {
                            // Push object with all metrics
                            measurements.push({
                                shoulder: shoulderCm,
                                hip: hipCm,
                                torso: torsoCm
                            });
                        }

                        // Visual feedback - draw shoulder line
                        ctx.beginPath();
                        ctx.moveTo(leftShoulder.x, leftShoulder.y);
                        ctx.lineTo(rightShoulder.x, rightShoulder.y);
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 4;
                        ctx.stroke();

                        // Draw Hip Line if detected
                        if (hipCm > 0) {
                            ctx.beginPath();
                            ctx.moveTo(leftHip.x, leftHip.y);
                            ctx.lineTo(rightHip.x, rightHip.y);
                            ctx.strokeStyle = '#ff00ff';
                            ctx.lineWidth = 4;
                            ctx.stroke();
                        }

                        ctx.fillStyle = '#00ffff';
                        ctx.fillText(`${shoulderCm.toFixed(1)} cm`, (leftShoulder.x + rightShoulder.x) / 2, (leftShoulder.y + rightShoulder.y) / 2 - 20);

                        // Update progress bar
                        const progress = Math.min(100, (measurements.length / 30) * 100);
                        if (progressBar) progressBar.style.width = `${progress}%`;
                        if (progressText) progressText.innerText = `${measurements.length} / 30 samples`;

                        // AUTO CAPTURE when we have enough samples
                        if (measurements.length >= 30) {
                            this.finishMeasurement();
                        }
                    } else if (isRotated) {
                        // Rotation warning
                        if (guidanceText) guidanceText.innerText = "üîÑ Face Forward";
                        if (guidanceHint) guidanceHint.innerText = "Your body is turned - face camera directly";
                        this.updateBodyOutlineColor('rgba(255,180,50,0.7)', 'bg-orange-500/80 text-white', 'üîÑ STRAIGHTEN UP');
                    }
                } else {
                    // No pose detected
                    if (guidanceText) guidanceText.innerText = "üë§ No Person Detected";
                    if (guidanceHint) guidanceHint.innerText = "Stand in front of the camera";
                }
            }



            drawSkeleton(keypoints) {
                // Simple skeleton drawing
                keypoints.forEach(kp => {
                    if (kp.score > 0.5) {
                        ctx.beginPath();
                        ctx.arc(kp.x, kp.y, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = kp.score > 0.8 ? '#00ff00' : '#ffff00';
                        ctx.fill();
                    }
                });
            }

            finishMeasurement() {
                // Average measurements (handle objects)
                const samples = measurements.length;
                const avgShoulderCm = measurements.reduce((a, b) => a + b.shoulder, 0) / samples;
                const avgHipCm = measurements.reduce((a, b) => a + (b.hip || 0), 0) / samples;
                const avgTorsoCm = measurements.reduce((a, b) => a + (b.torso || 0), 0) / samples;

                // Calculate Chest - IMPROVED FORMULA
                // Old: Chest ‚âà Shoulder * 2.35
                // New: Chest ‚âà (Shoulder * 2.0) + (Hip * 0.4) + Padding
                // This accounts for body taper/shape better than just shoulders

                let chestCm = 0;
                if (avgHipCm > 0) {
                    chestCm = (avgShoulderCm * 1.8) + (avgHipCm * 0.7);
                } else {
                    // Fallback if hips weren't detected
                    chestCm = avgShoulderCm * 2.35;
                }

                // Determine Size
                const size = this.getSize(chestCm);

                // Show Results - populate editable inputs
                document.getElementById('result-size').innerText = size;
                document.getElementById('input-chest').value = chestCm.toFixed(1);
                document.getElementById('input-shoulder').value = avgShoulderCm.toFixed(1);

                // Store original values for edit tracking
                originalChestCm = chestCm;
                originalShoulderCm = avgShoulderCm;
                wasEdited = false;
                document.getElementById('edit-notice').classList.add('hidden');

                document.getElementById('instructions-panel').classList.add('hidden');
                document.getElementById('results-panel').classList.remove('hidden');

                this.updateStatus(STATE.SHOW_RESULTS);
                appState = STATE.SHOW_RESULTS; // Stop loop processing

                // Init 3D scene after panel is visible (needs proper dimensions)
                // Use setTimeout to ensure DOM is fully painted
                setTimeout(() => {
                    if (!threeRenderer) {
                        this.init3D();
                    }
                    // Update 3D Model Scale
                    if (torsoMesh) {
                        const scaleFactor = chestCm / 100;
                        torsoMesh.scale.set(scaleFactor, 1, scaleFactor * 0.8);
                    }
                }, 100);

                // Capture image
                const image = canvas.toDataURL('image/jpeg');

                // Get employee name from input
                const employeeName = document.getElementById('input-employee-name').value.trim() || 'Unknown';

                // Store result temporarily
                currentResult = {
                    name: employeeName,
                    date: new Date().toLocaleString(),
                    size: size,
                    chest: chestCm.toFixed(1),
                    shoulder: avgShoulderCm.toFixed(1),
                    hip: avgHipCm.toFixed(1),
                    torso: avgTorsoCm.toFixed(1),
                    image: image,
                    edited: false
                };
            }

            recalculateSize() {
                const newChestCm = parseFloat(document.getElementById('input-chest').value);
                const newShoulderCm = parseFloat(document.getElementById('input-shoulder').value);

                if (isNaN(newChestCm) || isNaN(newShoulderCm)) {
                    alert("Please enter valid numbers.");
                    return;
                }

                // Check if values were modified
                if (Math.abs(newChestCm - originalChestCm) > 0.5 || Math.abs(newShoulderCm - originalShoulderCm) > 0.5) {
                    wasEdited = true;
                    document.getElementById('edit-notice').classList.remove('hidden');
                }

                // Recalculate size based on (potentially) edited chest
                const newSize = this.getSize(newChestCm);
                document.getElementById('result-size').innerText = newSize;

                // Update 3D model
                if (torsoMesh) {
                    const scaleFactor = newChestCm / 100;
                    torsoMesh.scale.set(scaleFactor, 1, scaleFactor * 0.8);
                }

                // Update currentResult
                if (currentResult) {
                    currentResult.chest = newChestCm.toFixed(1);
                    currentResult.shoulder = newShoulderCm.toFixed(1);
                    currentResult.size = newSize;
                    currentResult.edited = wasEdited;
                }
            }

            getSize(chestCm) {
                // UPDATED size chart based on industry standards
                if (chestCm < 88) return 'XS';
                if (chestCm < 96) return 'S';
                if (chestCm < 104) return 'M';
                if (chestCm < 112) return 'L';
                if (chestCm < 120) return 'XL';
                if (chestCm < 128) return 'XXL';
                return '3XL';
            }

            async saveCurrentResult() {
                if (currentResult) {
                    if (!currentResult.name || currentResult.name === 'Unknown') {
                        const name = prompt("Please enter employee name:");
                        if (name && name.trim()) {
                            currentResult.name = name.trim();
                        } else {
                            alert("Employee name is required!");
                            return;
                        }
                    }
                    try {
                        await db.save(currentResult);
                        alert(`Saved: ${currentResult.name} - Size ${currentResult.size}`);
                        // Clear the name input for next employee
                        document.getElementById('input-employee-name').value = '';
                    } catch (e) {
                        console.error(e);
                        alert("Failed to save result.");
                    }
                }
            }

            async toggleDashboard() {
                const dashboard = document.getElementById('dashboard-view');
                const isHidden = dashboard.classList.contains('hidden');

                if (isHidden) {
                    // Show
                    dashboard.classList.remove('hidden');
                    await this.loadDashboardData();
                } else {
                    // Hide
                    dashboard.classList.add('hidden');
                }
            }

            async loadDashboardData() {
                const data = await db.getAll();
                const tbody = document.getElementById('history-table-body');
                tbody.innerHTML = '';

                data.reverse().forEach(item => {
                    const row = document.createElement('tr');
                    row.className = 'border-b border-gray-100 hover:bg-gray-50 transition-colors';
                    const editedBadge = item.edited
                        ? '<span class="px-2 py-1 bg-amber-100 text-amber-700 rounded-full text-xs font-medium">Edited</span>'
                        : '<span class="px-2 py-1 bg-green-100 text-green-700 rounded-full text-xs font-medium">AI</span>';
                    row.innerHTML = `
                        <td class="p-4 font-bold text-gray-900">${item.name || 'Unknown'}</td>
                        <td class="p-4"><span class="px-3 py-1 bg-gray-900 text-white rounded-full text-xs font-bold">${item.size}</span></td>
                        <td class="p-4 text-gray-600">${item.chest} cm</td>
                        <td class="p-4 text-gray-600">${item.shoulder} cm</td>
                        <td class="p-4">${editedBadge}</td>
                        <td class="p-4 text-gray-500 text-sm">${item.date}</td>
                        <td class="p-4">
                            <img src="${item.image}" class="w-12 h-12 object-cover rounded-lg border border-gray-200 cursor-pointer hover:scale-110 transition-transform" onclick="app.downloadImage('${item.image}')">
                        </td>
                    `;
                    tbody.appendChild(row);
                });
            }

            downloadImage(dataUrl) {
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `size-ai-capture-${Date.now()}.jpg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            async exportToExcel() {
                const data = await db.getAll();
                if (data.length === 0) {
                    alert("No data to export!");
                    return;
                }

                // Prepare data for sheet - Employee Name first
                const sheetData = data.map(item => ({
                    "Employee": item.name || 'Unknown',
                    "Size": item.size,
                    "Chest (cm)": item.chest,
                    "Shoulder (cm)": item.shoulder,
                    "Status": item.edited ? "Manually Edited" : "AI Measured",
                    "Date": item.date
                }));

                const ws = XLSX.utils.json_to_sheet(sheetData);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Team Measurements");

                XLSX.writeFile(wb, `TailoredAI_Team_${new Date().toISOString().split('T')[0]}.xlsx`);
            }

            async clearAllData() {
                if (confirm("Are you sure you want to delete ALL measurement data? This cannot be undone.")) {
                    try {
                        await db.clearAll();
                        await this.loadDashboardData();
                        alert("All data cleared. Ready for a new session.");
                    } catch (e) {
                        console.error(e);
                        alert("Failed to clear data.");
                    }
                }
            }
        }

        // --- INIT ---
        function onOpenCvReady() {
            // OpenCV ready callback
        }

        window.onload = () => {
            window.app = new App();
        };

    </script>
</body>

</html>