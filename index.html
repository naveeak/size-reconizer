<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TailoredAI - T-Shirt Size Predictor</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>

    <!-- SheetJS for Excel Export -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>

    <!-- MediaPipe BlazePose -->
    <script
        src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection@2.1.3/dist/pose-detection.min.js"></script>

    <!-- OpenCV.js -->
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();"
        type="text/javascript"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        /* Custom Animations */
        @keyframes scan {
            0% {
                top: 0%;
                opacity: 0;
            }

            50% {
                opacity: 1;
            }

            100% {
                top: 100%;
                opacity: 0;
            }
        }

        .scan-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 4px;
            background: #00ff00;
            box-shadow: 0 0 10px #00ff00;
            animation: scan 2s linear infinite;
        }

        .glass-panel {
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(0, 0, 0, 0.05);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05);
        }

        /* Scrollbar for dashboard */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #f3f4f6;
        }

        ::-webkit-scrollbar-thumb {
            background: #d1d5db;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #9ca3af;
        }

        /* Premium Font */
        body {
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
        }
    </style>
</head>

<body class="bg-gray-50 text-gray-900 h-screen overflow-hidden flex flex-col font-sans">

    <!-- Header -->
    <header class="h-16 flex items-center justify-between px-8 bg-white border-b border-gray-200 z-10 shadow-sm">
        <div class="flex items-center gap-3 cursor-pointer" onclick="app.toggleDashboard()">
            <span class="text-2xl">üìè</span>
            <h1 class="text-xl font-bold text-gray-900 tracking-tight">
                TAILORED<span class="font-light text-gray-500">AI</span>
            </h1>
        </div>
        <div class="flex items-center gap-4">
            <button onclick="app.toggleDashboard()"
                class="text-sm font-medium text-gray-600 hover:text-gray-900 flex items-center gap-2 transition-colors">
                <span class="bg-gray-100 p-2 rounded-full">üìä</span> <span class="hidden md:inline">Dashboard</span>
            </button>
            <div id="status-indicator"
                class="flex items-center gap-2 px-4 py-1.5 rounded-full bg-blue-50 text-blue-700 text-xs font-semibold uppercase tracking-wide border border-blue-100">
                <span class="w-2 h-2 rounded-full bg-blue-500 animate-pulse"></span>
                <span id="status-text">Initializing...</span>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 relative flex flex-col md:flex-row overflow-hidden">

        <!-- Dashboard Overlay (Initially Hidden) -->
        <div id="dashboard-view"
            class="hidden absolute inset-0 z-40 bg-white/95 backdrop-blur-sm flex flex-col p-8 overflow-hidden transition-all duration-300">
            <div class="flex justify-between items-center mb-8 max-w-6xl mx-auto w-full">
                <div>
                    <h2 class="text-3xl font-bold text-gray-900">Measurement History</h2>
                    <p class="text-gray-500 mt-1">Track your size evolution over time.</p>
                </div>
                <div class="flex gap-3">
                    <button onclick="app.exportToExcel()"
                        class="px-5 py-2.5 bg-green-600 hover:bg-green-700 text-white rounded-lg font-medium shadow-sm flex items-center gap-2 transition-all">
                        üì• Export Excel
                    </button>
                    <button onclick="app.toggleDashboard()"
                        class="px-5 py-2.5 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-lg font-medium transition-all">
                        Close
                    </button>
                </div>
            </div>

            <div
                class="flex-1 overflow-auto bg-white rounded-2xl border border-gray-200 shadow-xl max-w-6xl mx-auto w-full">
                <table class="w-full text-left border-collapse">
                    <thead class="bg-gray-50 text-gray-600 sticky top-0 z-10">
                        <tr>
                            <th class="p-5 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">Date
                            </th>
                            <th class="p-5 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">Size
                            </th>
                            <th class="p-5 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">
                                Chest</th>
                            <th class="p-5 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">
                                Shoulder</th>
                            <th class="p-5 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">
                                Capture</th>
                            <th class="p-5 font-semibold text-sm uppercase tracking-wider border-b border-gray-200">
                                Actions</th>
                        </tr>
                    </thead>
                    <tbody id="history-table-body" class="divide-y divide-gray-100 text-gray-700">
                        <!-- Rows will be populated here -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Video Feed Area -->
        <div class="relative flex-1 bg-gray-100 flex items-center justify-center overflow-hidden">
            <div class="relative w-full h-full max-w-4xl max-h-[80vh] rounded-2xl overflow-hidden shadow-2xl bg-black">
                <!-- Video Element (Hidden, used for processing) -->
                <video id="webcam" class="absolute inset-0 w-full h-full object-cover opacity-0" playsinline></video>

                <!-- Canvas Overlay (Visible) -->
                <canvas id="output-canvas" class="absolute inset-0 w-full h-full object-contain"></canvas>

                <!-- UI Overlays -->
                <div id="guide-overlay" class="absolute inset-0 pointer-events-none flex items-center justify-center">
                    <!-- Card Guide -->
                    <div id="card-guide"
                        class="hidden border-4 border-dashed border-white/80 rounded-xl w-64 h-40 flex items-center justify-center relative shadow-lg backdrop-blur-sm">
                        <p class="text-white font-bold bg-black/40 px-4 py-2 rounded-lg backdrop-blur-md">Place Card
                            Here</p>
                    </div>

                    <!-- Pose Guide -->
                    <div id="pose-guide" class="hidden absolute inset-0 flex items-center justify-center">
                        <div
                            class="border-2 border-white/50 w-1/3 h-3/4 rounded-full shadow-[0_0_50px_rgba(255,255,255,0.2)]">
                        </div>
                    </div>
                </div>

                <!-- Manual Capture Button -->
                <div id="capture-container" class="absolute bottom-8 left-0 right-0 flex justify-center z-30 hidden">
                    <button onclick="app.manualCapture()"
                        class="w-16 h-16 rounded-full bg-white border-4 border-gray-300 shadow-lg flex items-center justify-center hover:scale-110 transition-transform active:scale-95 group">
                        <div class="w-12 h-12 rounded-full bg-red-500 group-hover:bg-red-600 transition-colors"></div>
                    </button>
                </div>

                <!-- Loading Spinner -->
                <div id="loader" class="absolute inset-0 flex flex-col items-center justify-center bg-white z-50">
                    <div class="w-16 h-16 border-4 border-gray-200 border-t-gray-900 rounded-full animate-spin mb-6">
                    </div>
                    <p class="text-gray-500 font-medium tracking-wide animate-pulse">INITIALIZING AI...</p>
                </div>
            </div>
        </div>

        <!-- Sidebar / Results Panel -->
        <div
            class="md:w-96 bg-white border-l border-gray-200 flex flex-col z-20 shadow-xl transition-transform duration-300 transform translate-y-full md:translate-y-0 absolute md:relative bottom-0 w-full h-2/3 md:h-full">

            <!-- Instructions Panel -->
            <div id="instructions-panel" class="p-8 flex-1 overflow-y-auto">
                <div class="mb-8">
                    <h2 class="text-xs font-bold text-gray-400 uppercase tracking-widest mb-4">Calibration Mode</h2>
                    <div class="flex gap-3">
                        <button onclick="app.setCalibrationMethod('card')"
                            class="flex-1 py-3 bg-gray-900 text-white rounded-lg text-sm font-medium hover:bg-gray-800 transition-all shadow-md">üí≥
                            Card</button>
                        <button onclick="app.setCalibrationMethod('height')"
                            class="flex-1 py-3 bg-white border border-gray-200 text-gray-700 rounded-lg text-sm font-medium hover:bg-gray-50 transition-all">üìè
                            Height</button>
                    </div>
                </div>

                <h2 class="text-xs font-bold text-gray-400 uppercase tracking-widest mb-6">Step-by-Step Guide</h2>

                <div class="space-y-8">
                    <div class="flex gap-5 items-start group">
                        <div
                            class="w-10 h-10 rounded-full bg-gray-100 text-gray-600 flex items-center justify-center font-bold shrink-0 group-hover:bg-gray-900 group-hover:text-white transition-colors">
                            1</div>
                        <div>
                            <h3 class="font-bold text-gray-900 mb-1">Calibrate</h3>
                            <p class="text-sm text-gray-500 leading-relaxed">
                                <b>Card:</b> Hold a standard card against your chest.<br>
                                <b>Height:</b> Enter your height and stand back.
                            </p>
                        </div>
                    </div>

                    <div class="flex gap-5 items-start group">
                        <div
                            class="w-10 h-10 rounded-full bg-gray-100 text-gray-600 flex items-center justify-center font-bold shrink-0 group-hover:bg-gray-900 group-hover:text-white transition-colors">
                            2</div>
                        <div>
                            <h3 class="font-bold text-gray-900 mb-1">Pose</h3>
                            <p class="text-sm text-gray-500 leading-relaxed">Step back until your full upper body is
                                visible. Stand straight with arms relaxed.</p>
                        </div>
                    </div>

                    <div class="mt-8 p-5 bg-blue-50 rounded-xl border border-blue-100">
                        <p class="text-sm text-blue-800 font-medium">üí° Tip: Ensure good lighting for best results.</p>
                    </div>
                </div>
            </div>

            <!-- Results Panel (Hidden initially) -->
            <div id="results-panel" class="hidden absolute inset-0 bg-white p-8 flex flex-col">
                <div class="text-center mb-4">
                    <h2 class="text-2xl font-bold text-gray-900">Analysis Complete</h2>
                    <p class="text-gray-500 text-sm">Here is your tailored size recommendation.</p>
                </div>

                <div class="flex-1 flex flex-col items-center justify-center">
                    <!-- 3D Model Container -->
                    <div id="three-container"
                        class="w-full h-48 bg-gray-50 rounded-xl mb-4 overflow-hidden border border-gray-100 relative">
                        <!-- Canvas will be injected here -->
                    </div>

                    <div class="relative mb-6">
                        <div class="absolute inset-0 bg-gray-900 rounded-full opacity-5 blur-xl"></div>
                        <div
                            class="relative w-24 h-24 rounded-full bg-gray-900 flex items-center justify-center shadow-2xl">
                            <span id="result-size" class="text-4xl font-bold text-white">L</span>
                        </div>
                    </div>

                    <div class="w-full space-y-4 bg-gray-50 p-6 rounded-2xl border border-gray-100">
                        <div class="flex justify-between items-center">
                            <span class="text-gray-500 text-sm font-medium">Chest Circumference</span>
                            <span id="result-chest" class="font-mono font-bold text-gray-900 text-lg">102 cm</span>
                        </div>
                        <div class="w-full h-px bg-gray-200"></div>
                        <div class="flex justify-between items-center">
                            <span class="text-gray-500 text-sm font-medium">Shoulder Width</span>
                            <span id="result-shoulder" class="font-mono font-bold text-gray-900 text-lg">46 cm</span>
                        </div>
                    </div>
                </div>

                <div class="mt-8 space-y-3">
                    <button onclick="app.saveCurrentResult()"
                        class="w-full py-4 bg-gray-900 hover:bg-gray-800 text-white rounded-xl font-bold tracking-wide transition-all shadow-lg hover:shadow-xl transform hover:-translate-y-0.5">
                        SAVE RESULT
                    </button>
                    <button onclick="app.reset()"
                        class="w-full py-4 bg-white border border-gray-200 hover:bg-gray-50 text-gray-900 rounded-xl font-bold tracking-wide transition-colors">
                        MEASURE AGAIN
                    </button>
                </div>
            </div>

        </div>
    </main>

    <script>
        // --- APP STATE & CONFIG ---
        const CONFIG = {
            cardWidthMm: 85.6,
            cardHeightMm: 53.98,
            cardAspectRatio: 85.6 / 53.98, // ~1.585
            aspectRatioTolerance: 0.15,
            minCardArea: 5000,
            confidenceThreshold: 0.7,
            smoothingWindow: 10
        };

        const STATE = {
            INIT: 'initializing',
            WAITING_PERMISSIONS: 'waiting_permissions',
            DETECTING_CARD: 'detecting_card',
            DETECTING_POSE: 'detecting_pose',
            CALCULATING: 'calculating',
            SHOW_RESULTS: 'results',
            ERROR: 'error'
        };

        // --- DATABASE HELPER ---
        const DB_NAME = 'SizeAIDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'measurements';

        class Database {
            constructor() {
                this.db = null;
            }

            async init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);

                    request.onerror = (event) => {
                        console.error("DB Error", event);
                        reject("DB Error");
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            db.createObjectStore(STORE_NAME, { keyPath: "id", autoIncrement: true });
                        }
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log("DB Initialized");
                        resolve();
                    };
                });
            }

            async save(data) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([STORE_NAME], "readwrite");
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.add(data);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            async getAll() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([STORE_NAME], "readonly");
                    const store = transaction.objectStore(STORE_NAME);
                    const request = store.getAll();

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }
        }

        // --- GLOBAL VARIABLES ---
        let appState = STATE.INIT;
        let video, canvas, ctx;
        let detector;
        let scalePxPerCm = 0;
        let measurements = [];
        let opencvLoaded = false;
        let db = new Database();
        let currentResult = null; // Store temp result for saving
        let threeScene, threeCamera, threeRenderer, torsoMesh;

        // --- MAIN APP CLASS ---
        class App {
            constructor() {
                this.init();
            }

            async init() {
                this.updateStatus(STATE.INIT);

                video = document.getElementById('webcam');
                canvas = document.getElementById('output-canvas');
                ctx = canvas.getContext('2d');

                try {
                    // 0. Init DB
                    await db.init();

                    // 1. Setup Camera
                    await this.setupCamera();

                    // 2. Load Models
                    await this.loadModels();

                    // 3. Wait for OpenCV
                    await this.waitForOpenCV();

                    // 4. Init 3D Scene
                    this.init3D();

                    // 5. Start Loop
                    this.updateStatus(STATE.DETECTING_CARD);
                    document.getElementById('loader').classList.add('hidden');
                    this.loop();

                } catch (error) {
                    console.error("Initialization failed:", error);
                    this.showError(error.message);
                }
            }

            async setupCamera() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 },
                        facingMode: 'user'
                    }
                });
                video.srcObject = stream;

                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        video.play();
                        // CRITICAL FIX: Set explicit attributes for OpenCV
                        video.width = video.videoWidth;
                        video.height = video.videoHeight;
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        resolve();
                    };
                });
            }

            async loadModels() {
                await tf.ready();
                detector = await poseDetection.createDetector(
                    poseDetection.SupportedModels.BlazePose,
                    {
                        runtime: 'tfjs',
                        modelType: 'full',
                        enableSmoothing: true
                    }
                );
                console.log("BlazePose loaded");
            }

            async waitForOpenCV() {
                return new Promise((resolve) => {
                    const check = setInterval(() => {
                        if (typeof cv !== 'undefined' && cv.Mat) {
                            clearInterval(check);
                            opencvLoaded = true;
                            console.log("OpenCV loaded");
                            resolve();
                        }
                    }, 100);
                });
            }

            init3D() {
                const container = document.getElementById('three-container');
                // Wait for container to exist/be visible or just init
                if (!container) return;

                const width = container.clientWidth || 300;
                const height = container.clientHeight || 200;

                threeScene = new THREE.Scene();
                threeScene.background = new THREE.Color(0xf9fafb); // Gray-50

                threeCamera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
                threeCamera.position.z = 5;
                threeCamera.position.y = 0.5;

                threeRenderer = new THREE.WebGLRenderer({ antialias: true });
                threeRenderer.setSize(width, height);
                container.appendChild(threeRenderer.domElement);

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                threeScene.add(ambientLight);

                const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
                dirLight.position.set(2, 5, 5);
                threeScene.add(dirLight);

                // Placeholder Torso Geometry
                const geometry = new THREE.CylinderGeometry(0.8, 0.6, 2, 32);
                const material = new THREE.MeshPhongMaterial({ color: 0x111827 }); // Gray-900
                torsoMesh = new THREE.Mesh(geometry, material);
                threeScene.add(torsoMesh);

                // Animation Loop for 3D
                const animate3D = () => {
                    requestAnimationFrame(animate3D);
                    if (torsoMesh) {
                        torsoMesh.rotation.y += 0.01;
                    }
                    threeRenderer.render(threeScene, threeCamera);
                };
                animate3D();
            }

            updateStatus(state, message) {
                appState = state;
                const statusText = document.getElementById('status-text');
                const indicator = document.getElementById('status-indicator');
                const cardGuide = document.getElementById('card-guide');
                const poseGuide = document.getElementById('pose-guide');
                const captureBtn = document.getElementById('capture-container');

                // Reset guides
                cardGuide.classList.add('hidden');
                poseGuide.classList.add('hidden');
                if (captureBtn) captureBtn.classList.add('hidden');

                switch (state) {
                    case STATE.INIT:
                        statusText.innerText = "Initializing System...";
                        indicator.className = "flex items-center gap-2 px-4 py-1.5 rounded-full bg-blue-50 text-blue-700 text-xs font-semibold uppercase tracking-wide border border-blue-100";
                        break;
                    case STATE.DETECTING_CARD:
                        statusText.innerText = "Hold Credit Card on Chest";
                        indicator.className = "flex items-center gap-2 px-4 py-1.5 rounded-full bg-blue-50 text-blue-700 text-xs font-semibold uppercase tracking-wide border border-blue-100";
                        cardGuide.classList.remove('hidden');
                        break;
                    case STATE.DETECTING_POSE:
                        statusText.innerText = "Stand Back & Pose";
                        indicator.className = "flex items-center gap-2 px-4 py-1.5 rounded-full bg-purple-50 text-purple-700 text-xs font-semibold uppercase tracking-wide border border-purple-100";
                        poseGuide.classList.remove('hidden');
                        if (captureBtn) captureBtn.classList.remove('hidden'); // Show capture button
                        break;
                    case STATE.SHOW_RESULTS:
                        statusText.innerText = "Analysis Complete";
                        indicator.className = "flex items-center gap-2 px-4 py-1.5 rounded-full bg-green-50 text-green-700 text-xs font-semibold uppercase tracking-wide border border-green-100";
                        break;
                }

                if (message) statusText.innerText = message;
            }

            showError(msg) {
                alert("Error: " + msg);
            }

            reset() {
                measurements = [];
                scalePxPerCm = 0;
                document.getElementById('results-panel').classList.add('hidden');
                document.getElementById('instructions-panel').classList.remove('hidden');

                if (this.useHeightMethod) {
                    this.updateStatus(STATE.DETECTING_POSE);
                } else {
                    this.updateStatus(STATE.DETECTING_CARD);
                }
            }

            setCalibrationMethod(method) {
                this.useHeightMethod = method === 'height';

                if (this.useHeightMethod) {
                    const h = prompt("Enter your height in CM:", "175");
                    if (h && !isNaN(h)) {
                        this.userHeightCm = parseFloat(h);
                        this.updateStatus(STATE.DETECTING_POSE);
                    } else {
                        this.useHeightMethod = false;
                    }
                } else {
                    this.updateStatus(STATE.DETECTING_CARD);
                }
            }

            async loop() {
                if (appState === STATE.ERROR) return;

                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

                if (appState === STATE.DETECTING_CARD && opencvLoaded) {
                    try {
                        this.processCardDetection();
                    } catch (e) {
                        console.error("CV Error:", e);
                        // Don't crash loop, just skip frame
                    }
                } else if (appState === STATE.DETECTING_POSE) {
                    await this.processPoseDetection();
                }

                requestAnimationFrame(() => this.loop());
            }

            processCardDetection() {
                // Initialize VideoCapture only once if possible, but for simplicity/robustness in this single-file setup:
                // We must ensure video dimensions match what OpenCV expects.
                if (video.videoWidth === 0 || video.videoHeight === 0) return;

                // OpenCV Card Detection Logic
                let src = new cv.Mat(video.height, video.width, cv.CV_8UC4);
                let cap = new cv.VideoCapture(video);
                cap.read(src);

                // 2. Preprocessing
                let gray = new cv.Mat();
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
                let blur = new cv.Mat();
                cv.GaussianBlur(gray, blur, new cv.Size(5, 5), 0);
                let edges = new cv.Mat();
                cv.Canny(blur, edges, 75, 200);

                // 3. Find Contours
                let contours = new cv.MatVector();
                let hierarchy = new cv.Mat();
                cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let bestRect = null;
                let maxArea = 0;

                for (let i = 0; i < contours.size(); ++i) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);

                    if (area > CONFIG.minCardArea) {
                        let peri = cv.arcLength(cnt, true);
                        let approx = new cv.Mat();
                        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

                        if (approx.rows === 4) {
                            let rect = cv.boundingRect(approx);
                            let aspectRatio = rect.width / rect.height;

                            let targetRatio = 53.98 / 85.6; // ~0.63
                            if (Math.abs(aspectRatio - targetRatio) < CONFIG.aspectRatioTolerance) {
                                if (area > maxArea) {
                                    maxArea = area;
                                    bestRect = rect;
                                }
                            }
                        }
                        approx.delete();
                    }
                }

                if (bestRect) {
                    // Draw bounding box
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 4;
                    ctx.strokeRect(bestRect.x, bestRect.y, bestRect.width, bestRect.height);

                    // Calculate Scale: Card Height is 85.6mm (since vertical)
                    let cardHeightCm = 8.56;
                    scalePxPerCm = bestRect.height / cardHeightCm; // pixels per cm

                    // Visual feedback
                    ctx.fillStyle = '#00ff00';
                    ctx.font = '20px Arial';
                    ctx.fillText(`Card Detected! Scale: ${scalePxPerCm.toFixed(2)} px/cm`, bestRect.x, bestRect.y - 10);

                    // Transition
                    setTimeout(() => {
                        this.updateStatus(STATE.DETECTING_POSE);
                    }, 1000);
                }

                // Cleanup
                src.delete(); gray.delete(); blur.delete(); edges.delete();
                contours.delete(); hierarchy.delete();
            }

            async processPoseDetection() {
                const poses = await detector.estimatePoses(video);

                if (poses.length > 0) {
                    const pose = poses[0];
                    this.drawSkeleton(pose.keypoints);

                    // If using Height Method, calculate scale from full body height
                    if (this.useHeightMethod) {
                        // We need full body: Nose (0) to Ankles (27, 28)
                        const nose = pose.keypoints[0];
                        const leftAnkle = pose.keypoints[27];
                        const rightAnkle = pose.keypoints[28];

                        // Check visibility
                        if (nose.score > 0.5 && leftAnkle.score > 0.5 && rightAnkle.score > 0.5) {
                            const ankleY = (leftAnkle.y + rightAnkle.y) / 2;
                            const heightPx = ankleY - nose.y; // Approx height in pixels

                            // Estimate body part length (Nose to Ankle is approx Height - 20cm)
                            const estimatedBodyPartCm = this.userHeightCm - 20;
                            scalePxPerCm = heightPx / estimatedBodyPartCm;

                            ctx.fillStyle = '#ffff00';
                            ctx.fillText(`Height Calib: ${scalePxPerCm.toFixed(2)} px/cm`, 20, 50);
                        } else {
                            ctx.fillStyle = '#ff0000';
                            ctx.fillText(`Show Full Body (Head to Feet)`, 20, 50);
                            // Don't return, let it try to measure shoulder if scale is set
                        }
                    }

                    // Check confidence
                    const leftShoulder = pose.keypoints[11];
                    const rightShoulder = pose.keypoints[12];

                    if (leftShoulder.score > CONFIG.confidenceThreshold && rightShoulder.score > CONFIG.confidenceThreshold && scalePxPerCm > 0) {
                        // Calculate Shoulder Width
                        const dx = leftShoulder.x - rightShoulder.x;
                        const dy = leftShoulder.y - rightShoulder.y;
                        const distPx = Math.sqrt(dx * dx + dy * dy);

                        const shoulderCm = distPx / scalePxPerCm;

                        // Accumulate measurements
                        measurements.push(shoulderCm);

                        // Visual feedback
                        ctx.beginPath();
                        ctx.moveTo(leftShoulder.x, leftShoulder.y);
                        ctx.lineTo(rightShoulder.x, rightShoulder.y);
                        ctx.strokeStyle = '#00ffff';
                        ctx.lineWidth = 4;
                        ctx.stroke();

                        ctx.fillStyle = '#00ffff';
                        ctx.fillText(`${shoulderCm.toFixed(1)} cm`, (leftShoulder.x + rightShoulder.x) / 2, (leftShoulder.y + rightShoulder.y) / 2 - 20);

                        // If we have enough samples, finish
                        // REMOVED AUTO FINISH for Manual Capture
                        // if (measurements.length > 30) {
                        //    this.finishMeasurement();
                        // }
                    }
                }
            }

            manualCapture() {
                if (measurements.length > 0) {
                    this.finishMeasurement();
                } else {
                    alert("No pose detected yet! Please stand back.");
                }
            }

            drawSkeleton(keypoints) {
                // Simple skeleton drawing
                keypoints.forEach(kp => {
                    if (kp.score > 0.5) {
                        ctx.beginPath();
                        ctx.arc(kp.x, kp.y, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = kp.score > 0.8 ? '#00ff00' : '#ffff00';
                        ctx.fill();
                    }
                });
            }

            finishMeasurement() {
                // Average measurements
                const avgShoulderCm = measurements.reduce((a, b) => a + b, 0) / measurements.length;

                // Calculate Chest (Empirical: Shoulder * PI * 0.85)
                const chestCm = avgShoulderCm * Math.PI * 0.85;

                // Determine Size
                const size = this.getSize(chestCm);

                // Show Results
                document.getElementById('result-size').innerText = size;
                document.getElementById('result-chest').innerText = `${chestCm.toFixed(1)} cm`;
                document.getElementById('result-shoulder').innerText = `${avgShoulderCm.toFixed(1)} cm`;

                document.getElementById('instructions-panel').classList.add('hidden');
                document.getElementById('results-panel').classList.remove('hidden');

                this.updateStatus(STATE.SHOW_RESULTS);
                appState = STATE.SHOW_RESULTS; // Stop loop processing

                // Update 3D Model Scale
                if (torsoMesh) {
                    // Base scale 1.0 = ~100cm chest
                    const scaleFactor = chestCm / 100;
                    torsoMesh.scale.set(scaleFactor, 1, scaleFactor * 0.8);
                }

                // Capture image
                const image = canvas.toDataURL('image/jpeg');

                // Store result temporarily
                currentResult = {
                    date: new Date().toLocaleString(),
                    size: size,
                    chest: chestCm.toFixed(1),
                    shoulder: avgShoulderCm.toFixed(1),
                    image: image
                };
            }

            getSize(chestCm) {
                // Simple mapping
                if (chestCm < 86) return 'XS';
                if (chestCm < 94) return 'S';
                if (chestCm < 102) return 'M';
                if (chestCm < 110) return 'L';
                if (chestCm < 118) return 'XL';
                if (chestCm < 126) return 'XXL';
                return '3XL';
            }

            async saveCurrentResult() {
                if (currentResult) {
                    try {
                        await db.save(currentResult);
                        alert("Result Saved to Dashboard!");
                    } catch (e) {
                        console.error(e);
                        alert("Failed to save result.");
                    }
                }
            }

            async toggleDashboard() {
                const dashboard = document.getElementById('dashboard-view');
                const isHidden = dashboard.classList.contains('hidden');

                if (isHidden) {
                    // Show
                    dashboard.classList.remove('hidden');
                    await this.loadDashboardData();
                } else {
                    // Hide
                    dashboard.classList.add('hidden');
                }
            }

            async loadDashboardData() {
                const data = await db.getAll();
                const tbody = document.getElementById('history-table-body');
                tbody.innerHTML = '';

                data.reverse().forEach(item => {
                    const row = document.createElement('tr');
                    row.className = 'border-b border-gray-100 hover:bg-gray-50 transition-colors';
                    row.innerHTML = `
                        <td class="p-5 font-medium text-gray-900">${item.date}</td>
                        <td class="p-5"><span class="px-3 py-1 bg-gray-900 text-white rounded-full text-xs font-bold tracking-wide">${item.size}</span></td>
                        <td class="p-5 text-gray-600">${item.chest}</td>
                        <td class="p-5 text-gray-600">${item.shoulder}</td>
                        <td class="p-5">
                            <img src="${item.image}" class="w-16 h-16 object-cover rounded-lg border border-gray-200 cursor-pointer hover:scale-110 transition-transform shadow-sm" onclick="app.downloadImage('${item.image}')">
                        </td>
                        <td class="p-5">
                            <button onclick="app.downloadImage('${item.image}')" class="text-blue-600 hover:text-blue-800 text-sm font-medium">Download</button>
                        </td>
                    `;
                    tbody.appendChild(row);
                });
            }

            downloadImage(dataUrl) {
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `size-ai-capture-${Date.now()}.jpg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            async exportToExcel() {
                const data = await db.getAll();
                if (data.length === 0) {
                    alert("No data to export!");
                    return;
                }

                // Prepare data for sheet
                const sheetData = data.map(item => ({
                    Date: item.date,
                    Size: item.size,
                    "Chest (cm)": item.chest,
                    "Shoulder (cm)": item.shoulder
                }));

                const ws = XLSX.utils.json_to_sheet(sheetData);
                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, "Measurements");

                XLSX.writeFile(wb, "SizeAI_Measurements.xlsx");
            }
        }

        // --- INIT ---
        function onOpenCvReady() {
            // OpenCV ready callback
        }

        window.onload = () => {
            window.app = new App();
        };

    </script>
</body>

</html>